// Generated by CoffeeScript 1.6.2
var analyzeRoutes, async, convertModel, convertType, createSchema, utils, _;

_ = require('underscore');

utils = require('./utils');

async = require('async');

createSchema = require('json-gate').createSchema;

convertType = function(swaggerType, parameter, allowMultiple, models) {
  var lowerType, type;

  if (swaggerType == null) {
    throw new Error("No type found for parameter " + parameter);
  }
  if (_.isArray(swaggerType)) {
    return _.map(swaggerType, function(type, i) {
      var id;

      if (_.isObject(type)) {
        id = utils.generate();
        type.id = id;
        delete type.type;
        swaggerType[i] = id;
        models[id] = type;
        type = id;
      }
      return convertType(type, parameter, allowMultiple, models);
    });
  }
  lowerType = swaggerType.toLowerCase();
  type = null;
  if (allowMultiple) {
    type = 'array';
  } else {
    switch (lowerType) {
      case 'int':
      case 'long':
      case 'integer':
        type = 'integer';
        break;
      case 'float':
      case 'double':
      case 'number':
        type = 'number';
        break;
      case 'string':
      case 'boolean':
      case 'array':
      case 'any':
      case 'null':
      case 'object':
        type = lowerType;
        break;
      case 'byte':
      case 'file':
        type = 'file';
        break;
      default:
        if (swaggerType in models) {
          type = 'object';
        } else {
          throw new Error("Unsupported type" + (parameter != null ? " for parameter " + parameter : '') + ": " + swaggerType);
        }
    }
  }
  return type;
};

convertModel = function(models, model, _stack) {
  var ltype, name, prop, result, _ref, _ref1, _ref2;

  result = {
    properties: {},
    additionalProperties: _.isObject(model.additionalProperties) ? model.additionalProperties : false
  };
  if (_stack == null) {
    _stack = [];
  }
  if (model.id != null) {
    if (-1 !== _stack.indexOf(model.id)) {
      _stack.push(model.id);
      throw new Error("Circular reference detected: " + (_stack.join(' > ')));
    }
    _stack.push(model.id);
  }
  _.extend(result.properties, model.properties);
  _ref = result.properties;
  for (name in _ref) {
    prop = _ref[name];
    _.extend(prop, model.properties[name]);
    if (((_ref1 = prop.allowableValues) != null ? _ref1.valueType : void 0) != null) {
      switch (prop.allowableValues.valueType.toLowerCase()) {
        case 'range':
          if ((prop.allowableValues.min != null) && (prop.allowableValues.max != null)) {
            prop.minimum = prop.allowableValues.min;
            prop.maximum = prop.allowableValues.max;
            if (prop.minimum > prop.maximum) {
              throw new Error("min value should not be greater tha max value in " + name);
            }
          } else {
            throw new Error("missing allowableValues.min and/or allowableValues.max parameters for allowableValues.range of " + name);
          }
          delete prop.allowableValues;
          break;
        case 'list':
          if ((prop.allowableValues.values != null) && _.isArray(prop.allowableValues.values)) {
            prop["enum"] = prop.allowableValues.values;
          } else {
            throw new Error("allowableValues.values is missing or is not an array for allowableValues.list of " + name);
          }
          delete prop.allowableValues;
      }
    }
    ltype = _.isString(prop.type) ? prop.type.toLowerCase() : '';
    if (prop.type in models) {
      _.extend(prop, convertModel(models, models[prop.type], _stack));
      prop.type = 'object';
    } else if ((ltype === 'list' || ltype === 'set' || ltype === 'array') && (((_ref2 = prop.items) != null ? _ref2.$ref : void 0) != null)) {
      _.extend(prop.items, convertModel(models, models[prop.items.$ref], _stack));
      delete prop.items.$ref;
      prop.items.type = 'object';
      prop.type = 'array';
    } else if (ltype === 'object') {
      _.extend(prop, convertModel(models, prop, _stack));
    } else {
      prop.type = convertType(prop.type, null, false, models);
    }
  }
  return result;
};

analyzeRoutes = function(prefix, descriptor) {
  var allowMultiple, api, operation, resource, route, routes, schema, spec, verb, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;

  routes = {};
  _ref = descriptor.apis;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    resource = _ref[_i];
    _ref1 = resource.apis;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      api = _ref1[_j];
      route = {};
      routes[prefix + utils.pathToRoute(api.path)] = route;
      _ref2 = api.operations;
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        operation = _ref2[_k];
        if (!(operation != null ? (_ref3 = operation.parameters) != null ? _ref3.length : void 0 : void 0)) {
          continue;
        }
        verb = [];
        route[operation.httpMethod.toUpperCase()] = verb;
        _ref4 = operation.parameters;
        for (_l = 0, _len3 = _ref4.length; _l < _len3; _l++) {
          spec = _ref4[_l];
          allowMultiple = spec.allowMultiple === true;
          schema = {
            type: convertType(spec.dataType, spec.name, allowMultiple, descriptor.models),
            required: spec.required === true
          };
          if (spec.name != null) {
            schema.title = spec.name;
          }
          if (spec.description != null) {
            schema.description = spec.description;
          }
          if (schema.type === 'object') {
            _.extend(schema, convertModel(descriptor.models, spec.properties ? spec : descriptor.models[spec.dataType]));
          }
          if (((_ref5 = spec.allowableValues) != null ? _ref5.valueType : void 0) != null) {
            switch (spec.allowableValues.valueType.toLowerCase()) {
              case 'range':
                if ((spec.allowableValues.min != null) && (spec.allowableValues.max != null)) {
                  schema.minimum = spec.allowableValues.min;
                  schema.maximum = spec.allowableValues.max;
                  if (schema.minimum > schema.maximum) {
                    throw new Error("min value should not be greater tha max value in " + spec.name);
                  }
                } else {
                  throw new Error("missing allowableValues.min and/or allowableValues.max parameters for allowableValues.range of " + spec.name);
                }
                break;
              case 'list':
                if ((spec.allowableValues.values != null) && _.isArray(spec.allowableValues.values)) {
                  schema["enum"] = spec.allowableValues.values;
                } else {
                  throw new Error("allowableValues.values is missing or is not an array for allowableValues.list of " + spec.name);
                }
            }
          }
          if (allowMultiple) {
            schema.items = _.clone(schema);
            schema.items.type = convertType(spec.dataType, spec.name, false, descriptor.models);
            delete schema.items.title;
            delete schema.items.description;
          }
          verb.push({
            kind: spec.paramType.toLowerCase(),
            name: spec.name,
            schema: createSchema(schema)
          });
        }
      }
    }
  }
  return routes;
};

module.exports = function(app) {
  var basePath, err, middleware;

  if (!((app != null ? app.handle : void 0) && ((app != null ? app.set : void 0) != null))) {
    throw new Error('No Express application provided');
  }
  if (app.descriptor == null) {
    throw new Error('No Swagger descriptor found within express application. Did you use swagger.generator middleware ?');
  }
  basePath = utils.extractBasePath(app.descriptor);
  middleware = function(req, res, next) {
    var process, route,
      _this = this;

    route = req.app._router.matchRequest(req);
    if (route && route.path in this.handle.routes && req.method.toUpperCase() in this.handle.routes[route.path]) {
      process = function() {
        req.input = {};
        return _this.handle.validate(req.method.toUpperCase(), route.path, req.path, req.query, req.headers, req, req.input, next);
      };
      if (req.is('json') || req.is('application/x-www-form-urlencoded') || req.is('multipart/form-data')) {
        return process();
      }
      delete req.body;
      req.on('data', function(chunk) {
        if (!req.body) {
          req.body = '';
        }
        return req.body += chunk;
      });
      return req.on('end', process);
    }
    return next();
  };
  middleware.routes = {};
  try {
    middleware.routes = analyzeRoutes(basePath, JSON.parse(JSON.stringify(app.descriptor)));
  } catch (_error) {
    err = _error;
    throw new Error("Failed to analyze descriptor: " + (err.toString()) + "\n" + err.stack);
  }
  middleware.validate = function(method, path, url, query, headers, bodyContainer, input, next) {
    var pathParamsNames, regex, specs, _ref;

    _ref = utils.extractParameters(path), regex = _ref[0], pathParamsNames = _ref[1];
    specs = this.routes[path][method];
    return async.forEach(specs, function(spec, done) {
      var errPrefix, match, type, value, _ref1;

      type = spec.schema.schema.type;
      value = null;
      errPrefix = null;
      switch (spec.kind) {
        case 'query':
          value = query[spec.name];
          errPrefix = "query parameter " + spec.name;
          break;
        case 'header':
          value = headers[spec.name];
          errPrefix = "header " + spec.name;
          break;
        case 'path':
          match = url.match(regex);
          value = match[pathParamsNames[spec.name]];
          if (value) {
            value = decodeURIComponent(value);
          }
          errPrefix = "path parameter " + spec.name;
          break;
        case 'body':
          errPrefix = "body parameter " + spec.name;
          if (spec.name) {
            if (type === 'file') {
              value = (_ref1 = bodyContainer.files) != null ? _ref1[spec.name] : void 0;
              return done(!(value != null) && spec.schema.schema.required ? new Error("" + errPrefix + " is required") : void 0);
            } else {
              if (bodyContainer.body) {
                value = bodyContainer.body[spec.name];
              } else {
                value = void 0;
              }
            }
          } else {
            errPrefix = 'body';
            value = bodyContainer.body;
          }
          break;
        default:
          throw new Error("unsupported parameter type " + spec.kind);
      }
      if (type === 'array') {
        if (value !== void 0) {
          value = _.isArray(value) ? value : _.isString(value) ? value.split(',') : [value];
          type = spec.schema.schema.items.type;
          value = _.map(value, function(v) {
            return utils.cast(type, v);
          });
        }
      } else {
        try {
          value = utils.cast(type, value);
        } catch (_error) {
          err = _error;
          return done("" + errPrefix + " " + err.message);
        }
      }
      return spec.schema.validate(value, function(err) {
        if (err != null) {
          err.message = "" + errPrefix + " " + (err.message.replace(/^JSON object /, ''));
        } else {
          if (spec.kind !== 'body') {
            input[spec.name] = value;
          } else {
            if (spec.name != null) {
              bodyContainer.body[spec.name] = value;
            } else {
              bodyContainer.body = value;
            }
          }
        }
        return done(err);
      });
    }, function(err) {
      if (err != null) {
        err.status = 400;
      }
      return next(err);
    });
  };
  return middleware;
};

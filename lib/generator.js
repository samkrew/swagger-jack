// Generated by CoffeeScript 1.6.2
var addRoutes, rawTypes, utils, validateModel, validateParameters, _,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

_ = require('underscore');

utils = require('./utils');

rawTypes = ['void', 'int', 'long', 'integer', 'float', 'double', 'number', 'string', 'boolean', 'array', 'any', 'null', 'byte', 'file'];

validateParameters = function(parameters, models, path, method) {
  var allowedDataTypes, duplicates, errorPrefix, name, parameter, pathParameters, routeParameters, routeParametersLength, __, _i, _len, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _results;

  errorPrefix = "Api " + path + " operation " + method;
  duplicates = _.chain(parameters).pluck('name').filter(function(p) {
    return p != null;
  }).countBy().pairs().filter(function(arr) {
    return arr[1] > 1;
  }).map(function(arr) {
    return arr[0];
  }).value();
  if (duplicates.length > 0) {
    throw new Error("" + errorPrefix + " has duplicates parameters: " + (duplicates.join(',')));
  }
  pathParameters = _.filter(parameters, function(p) {
    var _ref;

    return (p != null ? (_ref = p.paramType) != null ? _ref.toLowerCase() : void 0 : void 0) === 'path';
  });
  _ref = utils.extractParameters(utils.pathToRoute(path)), __ = _ref[0], routeParameters = _ref[1];
  routeParametersLength = _.keys(routeParameters).length;
  if (routeParametersLength !== pathParameters.length) {
    throw new Error("" + errorPrefix + " declares " + routeParametersLength + " parameters in its path, and " + pathParameters.length + " in its parameters array - you missed something");
  }
  for (name in routeParameters) {
    if (_.find(pathParameters, function(p) {
      return p.name === name;
    }) == null) {
      throw new Error("" + errorPrefix + " declares parameter " + name + " in its path, but not in its parameters array - propably a typo");
    }
  }
  if (_.filter(parameters, function(p) {
    var _ref1;

    return (p != null ? (_ref1 = p.paramType) != null ? _ref1.toLowerCase() : void 0 : void 0) === 'body' && !((p != null ? p.name : void 0) != null);
  }).length > 1) {
    throw new Error("" + errorPrefix + " has more than one anonymous body parameter - how is it possible M. Spock ?");
  }
  _results = [];
  for (_i = 0, _len = parameters.length; _i < _len; _i++) {
    parameter = parameters[_i];
    if (!(((parameter != null ? parameter.name : void 0) != null) || (parameter != null ? (_ref1 = parameter.paramType) != null ? _ref1.toLowerCase() : void 0 : void 0) === 'body')) {
      throw new Error("" + errorPrefix + " has a non body parameter with no name - are you a k-pop fan ?");
    }
    switch ((_ref2 = parameter.paramType) != null ? _ref2.toLowerCase() : void 0) {
      case 'path':
        if (parameter.required === false) {
          throw new Error("" + errorPrefix + " path parameter " + parameter.name + " cannot be optionnal - system_internal_error");
        }
        if (parameter.multipleAllowed === true) {
          throw new Error("" + errorPrefix + " path parameter " + parameter.name + " cannot allow multiple values - I'll be curious to see that");
        } else {
          _results.push(void 0);
        }
        break;
      case 'body':
        if ((_ref3 = method != null ? method.toLowerCase() : void 0) !== 'put' && _ref3 !== 'post') {
          throw new Error("" + errorPrefix + " does not allowed body parameters - do you really knows http ?");
        }
        allowedDataTypes = ['byte', 'boolean', 'int', 'long', 'float', 'double', 'string', 'date', 'file'];
        if (!((_ref4 = (_ref5 = parameter.dataType) != null ? _ref5.toLowerCase() : void 0, __indexOf.call(allowedDataTypes, _ref4) >= 0) || models[parameter.dataType])) {
          throw new Error("'" + parameter.dataType + "' does not match an allowed dataType [" + allowedDataTypes + "] nor a known model [" + (Object.keys(models)) + "]");
        } else {
          _results.push(void 0);
        }
        break;
      case 'header':
      case 'query':
        break;
      default:
        if (parameter.paramType != null) {
          throw new Error("" + errorPrefix + " parameter " + parameter.name + " type " + parameter.paramType + " is not supported - 42");
        } else {
          throw new Error("" + errorPrefix + " parameter " + parameter.name + " has no type - what else ?");
        }
    }
  }
  return _results;
};

validateModel = function(model, id, models) {
  if (model.id !== id) {
    throw new Error("model " + id + " not declared with the same id");
  }
  if (!(!_.isEmpty(model.properties) || model.additionalProperties || !_.isEmpty(model.items))) {
    throw new Error("model " + id + " does not declares properties");
  }
  if (models[id] != null) {
    throw new Error("model " + id + " has already been defined");
  }
  return model;
};

addRoutes = function(prefix, descriptor, resources) {
  var api, id, model, operation, parameter, resource, route, routes, verb, _base, _base1, _base2, _i, _j, _k, _l, _len, _len1, _len2, _len3, _name, _name1, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;

  routes = [];
  descriptor.apis = [];
  descriptor.models = {};
  for (_i = 0, _len = resources.length; _i < _len; _i++) {
    resource = resources[_i];
    if (!_.isObject(resource.api)) {
      throw new Error("Resource must contain 'api' attribute");
    }
    (_base = resource.api).models || (_base.models = {});
    _ref = resource.api.models;
    for (id in _ref) {
      model = _ref[id];
      descriptor.models[id] = validateModel(model, id, descriptor.models);
    }
    if (_.isObject(resource.controller)) {
      if (!_.isString(resource.api.resourcePath)) {
        throw new Error('Resource without path - are you kidding');
      }
      _ref1 = resource.api.apis;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        api = _ref1[_j];
        if (!_.isString(api.path)) {
          throw new Error("Resource " + resource.api.resourcePath + " has an api without path - D\'oh'");
        }
        if (0 !== api.path.indexOf(resource.api.resourcePath)) {
          throw new Error("Resource " + resource.api.resourcePath + " has an api " + api.path + " that did not match its own path - We beg your peer is sleeping'");
        }
        if (!_.isArray(api.operations)) {
          continue;
        }
        _ref2 = api.operations;
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          operation = _ref2[_k];
          if (!_.isString(operation.httpMethod)) {
            throw new Error("Api " + api.path + " has an operation without http method - what is the police doing ?");
          }
          verb = operation.httpMethod.toLowerCase();
          if (verb !== 'get' && verb !== 'post' && verb !== 'delete' && verb !== 'put' && verb !== 'options' && verb !== 'head') {
            throw new Error("Api " + api.path + " operation " + operation.httpMethod + " is not supported - I\'m so sorry Janice");
          }
          if (!_.isString(operation.nickname)) {
            throw new Error("Api " + api.path + " operation " + operation.httpMethod + " does not specify a nickname - we cannot guess the corresponding controller method");
          }
          if (operation.responseClass) {
            if (_ref3 = operation.responseClass.toLowerCase(), __indexOf.call(rawTypes, _ref3) < 0) {
              (_base1 = resource.api.models)[_name = operation.responseClass] || (_base1[_name] = descriptor.models[operation.responseClass]);
              if (resource.api.models[operation.responseClass] == null) {
                throw new Error("responseClass " + operation.responseClass + " doesn't match a model");
              }
            }
          } else {
            throw new Error("responseClass is mandatory. If no result expected, responseClass should be void");
          }
          if (_.isArray(operation.parameters)) {
            validateParameters(operation.parameters, descriptor.models, api.path, operation.httpMethod);
            _ref4 = operation.parameters;
            for (_l = 0, _len3 = _ref4.length; _l < _len3; _l++) {
              parameter = _ref4[_l];
              if (parameter.dataType && !(_ref5 = parameter.dataType, __indexOf.call(rawTypes, _ref5) >= 0)) {
                (_base2 = resource.api.models)[_name1 = parameter.dataType] || (_base2[_name1] = descriptor.models[parameter.dataType]);
              }
            }
          }
          route = utils.pathToRoute(api.path);
          if (!(operation.nickname in resource.controller)) {
            throw new Error("Api " + api.path + " nickname " + operation.nickname + " cannot be found in controller");
          }
          routes.push({
            method: verb,
            path: "" + prefix + route,
            middleware: resource.controller[operation.nickname]
          });
          if (/swagger/.test((_ref6 = process.env) != null ? _ref6.NODE_DEBUG : void 0)) {
            console.log("found a route " + prefix + route + " with verb " + verb + " bound to exported method " + operation.nickname);
          }
        }
      }
    }
    descriptor.apis.push(resource.api);
  }
  return routes;
};

module.exports = function(app, descriptor, resources, options) {
  var basePath, descRoute, err, err2, routes;

  if (options == null) {
    options = {};
  }
  if (!(((app != null ? app.route : void 0) != null))) {
    throw new Error('No Express application provided');
  }
  if (!_.isObject(descriptor)) {
    throw new Error('Provided root descriptor is not an object');
  }
  if (!_.isArray(resources)) {
    throw new Error('Provided resources must be an array');
  }
  if (!descriptor.basePath) {
    throw new Error('basePath is mandatory');
  }
  if (!descriptor.apiVersion) {
    throw new Error('apiVersion is mandatory');
  }
  basePath = "";
  options.descPath || (options.descPath = "api-docs.json");
  if (options.descPath[0] === '/') {
    options.descPath = options.descPath.slice(1);
  }
  descRoute = new RegExp("^" + basePath + "/" + options.descPath + "(/.*)?");
  if (!descriptor.swaggerVersion) {
    descriptor.swaggerVersion = '1.1';
  }
  try {
    routes = addRoutes(basePath, descriptor, resources);
    _.defer(function() {
      var route, _i, _len, _results;

      _results = [];
      for (_i = 0, _len = routes.length; _i < _len; _i++) {
        route = routes[_i];
        _results.push(app[route.method](route.path, route.middleware));
      }
      return _results;
    });
    app.descriptor = descriptor;
  } catch (_error) {
    err = _error;
    err2 = new Error("Failed to create routes from resources: " + (err.toString()));
    err2.stack = err.stack;
    throw err2;
  }
  return function(req, res, next) {
    var match, resource, result;

    match = descRoute.exec(req.path);
    if (match != null) {
      result = _.clone(descriptor);
      if (match[1] != null) {
        resource = _.find(descriptor.apis, function(res) {
          return match[1] === res.resourcePath;
        });
        if (resource == null) {
          return res.send(404);
        }
        result.resourcePath = resource.resourcePath;
        result.apis = resource.apis;
        result.models = resource.models;
      } else {
        result.apis = _.map(result.apis, function(api) {
          return {
            path: '/' + options.descPath + api.resourcePath,
            description: api.description
          };
        });
      }
      return res.json(result);
    }
    return next();
  };
};
